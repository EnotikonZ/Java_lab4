# Лабораторная работа lab4var9  
**Вариант 9**

Проект оформлен **в одном проекте**, но **в разных классах** (в нашем случае — два файла: `Lab4Var9.java` с классами и `Main4Var9.java` с единственным `main`).  
В `main` показана работа **всех задач** с дружественным интерфейсом.  
Все исходные данные вводятся **с клавиатуры**, реализована **проверка ввода**.  
Во всех классах присутствуют **поля**, **конструкторы** и **`toString()`**.

---

## Файлы проекта

- `Lab4Var9.java` — все сущности и методы задач (логика)
- `Main4Var9.java` — единственная точка входа, демонстрация всех задач

---

## Задача 1.3  
**Сравнимое**

### Условие
Создать ссылочный тип **Сравнимое**, гарантирующий наличие метода:
- называется `compare`
- принимает объект
- тип принимаемого объекта можно менять без изменения самого Сравнимого
- возвращает `int`

### Алгоритм решения
1. Создан интерфейс `ComparableItem<T>`.
2. Метод `compare(T other)` возвращает `int`.
3. Тип `T` задаётся параметризацией (generics), поэтому его можно менять без изменения интерфейса.

### Реализация
`Lab4Var9.ComparableItem<T>`

---

## Задача 1.4  
**Сравнимый студент**

### Условие
Создать сущность **Студент** и реализовать метод `compare` так, чтобы:
- если средняя оценка текущего студента больше → `1`
- если равны → `0`
- если меньше → `-1`

Создать двух студентов и сравнить.

### Алгоритм решения
1. Создан класс `Student` с полями: `name`, `grades`.
2. Реализован метод `average()` — вычисляет среднюю оценку (если оценок нет → 0).
3. Класс `Student` реализует `ComparableItem<Student>`.
4. В `compare` сравниваются средние значения.

### Демонстрация
В `Main4Var9` вводятся два студента с оценками, затем выводится результат сравнения и пояснение.

---

## Задача 2.3  
**Начало отсчёта**

### Условие
Создать метод, который принимает **Коробку** и кладёт в неё **трёхмерную точку** с произвольными значениями.  
Метод должен позволять передавать Коробку с более чем одним видом параметризации.

### Алгоритм решения
1. Создан класс `Box<T>` — хранит значение типа `T`.
2. Создан класс `Point3D` — координаты `x, y, z`.
3. Создан класс `StartPoint` с методом `putRandomPoint(Box<? super Point3D> box)`.
4. Использован wildcard `? super Point3D`, чтобы метод принимал:
   - `Box<Point3D>`
   - `Box<Object>` и другие более общие типы

### Демонстрация
В `Main4Var9` создаются:
- `Box<Object>`
- `Box<Point3D>`
Обе коробки заполняются методом `putRandomPoint(...)` и выводятся.

---

## Задача 3.1  
**Функция (map)**

### Условие
Разработать метод: принимает список `T` и объект с методом `apply(T)`, возвращает новый список `P`.  
Использование:
1. `["qwerty","asdfg","zx"]` → `[6,5,2]` (длины строк)
2. `[1,-3,7]` → `[1,3,7]` (модули)
3. список массивов `int[]` → список максимумов каждого массива

### Алгоритм решения
1. Создан функциональный интерфейс `Applier<T,P>`.
2. Реализован метод `map(List<T>, Applier<T,P>)`.
3. Для каждого элемента исходного списка применяется `apply`, результат добавляется в новый список.

### Демонстрация
В `Main4Var9` вводятся данные и выводятся результаты всех трёх примеров.

---

## Задача 3.2  
**Фильтр (filter)**

### Условие
Разработать метод: принимает список `T` и объект с методом `test(T)->boolean`, возвращает новый список `T` без элементов, не прошедших проверку.  
Использование:
1. фильтр строк длиной < 3
2. фильтр положительных (оставить отрицательные)
3. оставить только массивы без положительных элементов

### Алгоритм решения
1. Создан функциональный интерфейс `Tester<T>`.
2. Реализован метод `filter(List<T>, Tester<T>)`.
3. В новый список добавляются только элементы, где `test(...) == true`.

### Демонстрация
В `Main4Var9` результаты выводятся в консоль после ввода.

---

## Задача 3.3  
**Сокращение (reduce)**

### Условие
Разработать метод, который сводит список к одному значению `T`.  
Использование:
1. строки объединить в одну
2. числа сложить
3. список списков → общее количество элементов  
Далее изменить метод так, чтобы он не возвращал `null` и не падал на пустом списке.

### Алгоритм решения
1. Создан функциональный интерфейс `Reducer<T>` с методом `combine(T a, T b)`.
2. Реализован `reduce(List<T>, T identity, Reducer<T>)`:
   - используется `identity` как начальное значение
   - поэтому пустой список возвращает `identity` и не вызывает ошибок

### Демонстрация
В `Main4Var9`:
- склейка строк
- сумма чисел
- для списка списков: сначала `map` → размеры, затем `reduce` → сумма

---

## Задача 3.4  
**Коллекционирование (collect)**

### Условие
Метод возвращает коллекцию типа `P` со значениями типа `T`. Принимает:
1. исходный список
2. способ создания результирующей коллекции
3. способ добавления элементов

Использование:
1. числа разделить на два подсписка (положительные/отрицательные)
2. строки сгруппировать по длине
3. вернуть набор без повторов

### Алгоритм решения
1. Созданы интерфейсы:
   - `SupplierP<P>` — создание коллекции
   - `Accumulator<P,T>` — добавление элемента
2. Реализован метод `collect(List<T>, SupplierP<P>, Accumulator<P,T>)`.

### Демонстрация
В `Main4Var9`:
- формируются два подсписка чисел
- строится `Map<length, List<String>>`
- строится `Set<String>` для уникальных строк

